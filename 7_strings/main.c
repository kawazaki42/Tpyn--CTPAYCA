/**
 * @file
 * @brief   Задача 269-Д
 * 
 * @author  Николай Ковалев
 * 
 * @details Даны натуральное число n, символы s1,...,sn.
 *          Д) Найти какое-нибудь слово, начинающееся с буквы а.
 * 
 *          Слова - группы символов, разделенные пробелами
 *          (одним или несколькими) и не содержащие пробелов внутри себя.
 * 
 * Ссылка:  https://ivtipm.github.io/Programming/Glava08/index08.htm#z269
 */

#include <stdlib.h>  // EXIT_SUCCESS
#include <stdio.h>   // printf, scanf, getchar, ungetc
#include <locale.h>  // setlocale
// #include <string.h>  // strncmp
#include <ctype.h>   // isspace


/// Вывести одно слово со стандартного ввода на стандартный вывод.
/// Работает как:
/// ```c
///     scanf("%s", &str);
///     printf("%s", str);
/// ```
/// Но не пропускает пробелы в начале строки и не использует буфер,
/// scanf и printf, чтобы избежать переполнения.
void echo_one_word() {
    char cur = getchar();

    while( !isspace(cur) ) {
        putchar(cur);
        cur = getchar();
    }
}


/**
 * @brief Главная процедура
 * 
 * @return `EXIT_SUCCESS` (или 0) при успешном завершении
 * 
 *         `EXIT_FAILURE` при ошибке (напр. нехватка памяти)
 */
int main() {
    // Установить кодировку UTF-8
    // Локаль США (для разделителя-точки)
    setlocale(LC_ALL, "en_US.UTF8");


    // Ввод данных

    // /// Длина строки
    // int length;
    // printf("Длина строки в байтах (n): ");
    // scanf_s("%i ", &length);


    /// Искомый символ
    char look_for;
    printf("Искомый символ для начала слова: ");

    // 1 - длина буфера для scanf_s, т.е. ровно один символ
    scanf_s("%c", &look_for, 1);


    // printf("Введите строку из %d байт:\n", length);
    // puts("Остальное будет игнорировано");

    printf("\nВведите строку:\n");

    char cur;
    // Безусловный цикл
    while(1) {
        scanf_s(" ");     // Пропустить пробелы, если есть
        cur = getchar();  // Считать ровно один символ
        
        if(cur == look_for) {
            // Нашли символ в начале слова.
            ungetc(cur, stdin);  // 'Возвращаем' `cur` в очередь чтения
                                 // стандартного ввода.
            break;               // Завершаем цикл.
        }


        /* `ungetc` 'возвращает' считанный символ
         * в очередь чтения файла/потока данных.
         *
         * Почему это необходимо?
         * ======================
         *
         * При помощи `%s` мы хотим пропустить остаток слова.
         *
         * У однобуквенного слова нет остатка.
         * После него сразу идут пробелы.
         *
         * `%s` пропускает начальные пробелы,
         * поэтому поглощает целое слово после однобуквенного.
         *
         * Нужно вернуть символ в очередь ввода,
         * чтобы поглотилось только однобуквенное слово.
         */
        ungetc(cur, stdin);

        // 's' - слово, разделенное пробелами
        //       (как раз подходит для задачи).
        //
        //       NOTE: не просто строка, как в случае с `printf`!
        //
        // '*' - не сохранять значение в переменную.
        //
        // Результат: пропускает целое слово, начиная с символа `cur`.

        scanf_s("%*s");
    }


    // Вывод.

    putchar('\n');    // Отделить вывод переводом строки
    printf("Символ найден в начале слова '");
    echo_one_word();  // Ответ на задачу
    printf("'.");


    // Завершение
    putchar('\n');
    return EXIT_SUCCESS;
}