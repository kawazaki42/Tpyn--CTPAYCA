/**
 * @file
 * @brief   Задача 269-Д
 * 
 * @author  Николай Ковалев
 * 
 * @details Даны натуральное число n, символы s1,...,sn.
 *          Д) Найти какое-нибудь слово, начинающееся с буквы а.
 * 
 *          Слова - группы символов, разделенные пробелами
 *          (одним или несколькими) и не содержащие пробелов внутри себя.
 * 
 * Ссылка:  https://ivtipm.github.io/Programming/Glava08/index08.htm#z269
 */

#include <stdio.h>   // printf, scanf, getchar, ungetc
#include <locale.h>  // setlocale
#include <stdlib.h>  // EXIT_SUCCESS
#include <ctype.h>   // isspace
// #include <string.h>  // strncmp


/**
 * @brief Главная процедура
 * 
 * @return `EXIT_SUCCESS` (или 0) при успешном завершении
 * 
 *         `EXIT_FAILURE` при ошибке (напр. нехватка памяти)
 */
int main() {
    // Установить кодировку UTF-8
    // Локаль США (для разделителя-точки)
    setlocale(LC_ALL, "en_US.UTF8");


    // Ввод данных

    // /// Длина строки
    // int length;
    // printf("Длина строки в байтах (n): ");
    // scanf_s("%i ", &length);


    /// Искомый символ
    char look_for;
    printf("Искомый символ для начала слова: ");

    // 1 - длина буфера для scanf_s, т.е. ровно один символ
    scanf_s("%c", &look_for, 1);


    // printf("Введите строку из %d байт:\n", length);
    // puts("Остальное будет игнорировано");

    printf("Введите строку:\n");

    char cur;
    // Безусловный цикл
    while(1) {
        scanf_s(" ");     // Пропустить пробелы, если есть
        cur = getchar();  // Считать ровно один символ
        
        if(cur == look_for)
            // Нашли символ в начале слова
            break;
        else {
            // `ungetc` 'возвращает' считанный символ
            // в очередь чтения файла/потока данных.
            // 
            // Почему это необходимо?
            // ======================
            //
            // При помощи `%s` мы хотим пропустить остаток слова.
            //
            // У однобуквенного слова нет остатка.
            // После него сразу идут пробелы.
            //
            // `%s` пропускает начальные пробелы,
            // поэтому поглощает целое слово после однобуквенного.
            //
            // Нужно вернуть символ в очередь ввода,
            // чтобы поглотилось только однобуквенное слово.

            ungetc(cur, stdin);

            // 's' - слово, разделенное пробелами
            //       (как раз подходит для задачи).
            //
            //       NOTE: не просто строка, как в случае с `printf`!
            //
            // '*' - не сохранять значение в переменную.
            //
            // Результат: пропускает целое слово, начиная с символа `cur`.
            scanf_s("%*s");
        }
    }


    // Вывод.
    // Не используем printf - избегаем переполнения буфера.

    putchar('\n');

    while( !isspace(cur) ) {
        putchar(cur);
        cur = getchar();
    }

    // Завершение
    putchar('\n');
    return EXIT_SUCCESS;
}