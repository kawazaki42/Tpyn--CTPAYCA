/**
 * @file
 * @brief   Задача 269-Д
 * 
 * @author  Николай Ковалев
 * 
 * @details Даны натуральное число n, символы s1,...,sn.
 *          Д) Найти какое-нибудь слово, начинающееся с буквы а.
 * 
 *          Слова - группы символов, разделенные пробелами
 *          (одним или несколькими) и не содержащие пробелов внутри себя.
 * 
 * Ссылка:  https://ivtipm.github.io/Programming/Glava08/index08.htm#z269
 */

#include <stdlib.h>  // EXIT_SUCCESS
#include <stdio.h>   // printf, scanf, getchar, ungetc
#include <locale.h>  // setlocale
// #include <string.h>  // strncmp
#include <ctype.h>   // isspace


/// Вывести одно слово со стандартного ввода на стандартный вывод.
/// Работает как:
/// ```c
///     scanf("%s", &str);
///     printf("%s", str);
/// ```
/// Но не пропускает пробелы в начале строки и не использует буфер,
/// scanf и printf, чтобы избежать переполнения.
void echo_one_word() {
    char cur = getchar();

    while( !isspace(cur) ) {
        putchar(cur);
        cur = getchar();
    }
}


/**
 * @brief Главная процедура
 * 
 * @return `EXIT_SUCCESS` (или 0) при успешном завершении
 * 
 *         `EXIT_FAILURE` при ошибке (напр. нехватка памяти)
 */
int main() {
    // Установить кодировку UTF-8
    // Локаль США (для разделителя-точки)
    setlocale(LC_ALL, "en_US.UTF8");


    // Ввод данных

    // /// Длина строки
    // int length;
    // printf("Длина строки в байтах (n): ");
    // scanf_s("%i ", &length);


    /// Искомый символ
    char look_for;
    printf("Искомый символ для начала слова: ");

    // 1 - длина буфера для scanf_s, т.е. ровно один символ
    scanf_s("%c", &look_for, 1);


    // printf("Введите строку из %d байт:\n", length);
    // puts("Остальное будет игнорировано");

    printf("\nВведите строку:\n");

    char cur;
    // Безусловный цикл
    while(1) {
        // Операция 'peek': получить символ
        // без побочных эффектов (почти)

        // Пропустить пробелы, если есть и
        // считать ровно один символ
        scanf_s(" %c", &cur, 1);
        ungetc(cur, stdin);
        
        /* `ungetc` 'возвращает' считанный символ
        * в очередь чтения файла/потока данных.
        *
        * Почему это необходимо?
        * ======================
        *
        * При помощи `%s` мы хотим пропустить остаток слова.
        *
        * У однобуквенного слова нет остатка.
        * После него сразу идут пробелы.
        *
        * `%s` пропускает начальные пробелы,
        * поэтому поглощает целое слово после однобуквенного.
        *
        * Нужно вернуть символ в очередь ввода,
        * чтобы поглотилось только однобуквенное слово.
        */

        if(cur == look_for) {
            // Нашли символ в начале слова. Завершаем цикл.
            break;
        } else
            /* 's' - слово, разделенное пробелами
             *       (как раз подходит для задачи).
             *
             *       NOTE: не просто строка, как в случае с `printf`!
             *
             * '*' - не сохранять значение в переменную.
             *
             * Результат: пропускает целое слово, начиная с символа `cur`.
             */
            scanf_s("%*s");

    }


    // Вывод.

    putchar('\n');    // Отделить вывод переводом строки
    printf("Символ найден в начале слова '");
    echo_one_word();  // Ответ на задачу
    printf("'.");


    // Завершение
    putchar('\n');
    return EXIT_SUCCESS;
}